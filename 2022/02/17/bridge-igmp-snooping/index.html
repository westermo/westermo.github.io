<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Linux Bridge and IGMP Snooping</title>
  <meta name="description" content="This is the third post in a series of blog posts showing how to set up networking in Linux using low-level tools. In this part we talk about limiting the broadcast effects of multicast using IGMP/MLD snooping in the Linux bridge (software switch). Our context, as usual, is industrial networking with a focus on embedded devices.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://westermo.github.io/2022/02/17/bridge-igmp-snooping/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Westermo Labs" href="https://westermo.github.io/feed.xml">

  

  
  <meta property="og:title" content="Linux Bridge and IGMP Snooping">
  <meta property="og:site_name" content="Westermo Labs">
  <meta property="og:url" content="https://westermo.github.io/2022/02/17/bridge-igmp-snooping/">
  <meta property="og:description" content="This is the third post in a series of blog posts showing how to set up networking in Linux using low-level tools. In this part we talk about limiting the broadcast effects of multicast using IGMP/MLD snooping in the Linux bridge (software switch). Our context, as usual, is industrial networking with a focus on embedded devices.">
  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Linux Bridge and IGMP Snooping">
  <meta name="twitter:description" content="This is the third post in a series of blog posts showing how to set up networking in Linux using low-level tools. In this part we talk about limiting the broadcast effects of multicast using IGMP/M...">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Westermo Labs</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="https://github.com/westermo/">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Linux Bridge and IGMP Snooping</h1>
    
    <p class="post-meta"><time datetime="2022-02-17T14:32:24+01:00" itemprop="datePublished">Feb 17, 2022</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Joachim Wiberg</span></span>

 •
  
    
    
      
    
      
        <a href="/tags/howto/">howto</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
        <a href="/tags/bridge/">bridge</a>
      
    
      
    
      
    
      
    
      
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>This is the third post in a series of blog posts showing how to set up
networking in Linux using low-level tools.</p>

<p>In this part we talk about limiting the broadcast effects of multicast
using IGMP/MLD snooping in the Linux bridge (software switch).  Our
context, as usual, is industrial networking with a focus on embedded
devices.</p>

<!-- more -->

<h2>Introduction</h2>

<p>The Linux bridge recently gained support for per-VLAN IGMP/MLD snooping.
It stands fine on its own legs, with lots of new per-VLAN settings.  But
since it lives in the bridge, it cannot know about any VLAN interfaces
that may (or may not) sit on top of the bridge.  There are naming issues
(br0.1 vs vlan1), and the fact that an interface can have multiple IP
addresses assigned to it.  Therefore, the current bridge implementation
in <code class="language-plaintext highlighter-rouge">br_multicast.c</code> can only<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> act as a proxy querier, i.e., for IGMP
this means it can only send queries (per-VLAN) with source IP 0.0.0.0.</p>

<p>To understand why this might be a problem there are two things to
consider:</p>

<ol>
  <li>Some networks don’t have a (dynamic) multicast router<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>.  Usually
the multicast router is the IGMP/MLD querier for a LAN, but some
LANs consist only of (industrial) switches that try their best to
limit the spread of multicast<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup> on low-capacity links or to end
devices sensitive to too much data</li>
  <li>Some end-devices discard queries with source IP 0.0.0.0.  This is
of course wrong, but good luck telling a PLC vendor they should
change their embedded firmware of an aging product, or even the
customer site to upgrade their locked-down system with a brand new
firmware – these people don’t like change and sometimes because it
comes with drawn-out re-certification processes</li>
</ol>

<p>So, proxy queries are allowed per RFC, but that might not work with some
end-devices, and we can’t disable proxy-query because some end-devices
don’t do gratuitous join/leave.  Hence, we need a service to provide us
with an IGMP/MLD querier that can (at least) use one of the IP address
on the interfaces we have on top of the bridge.  Here we present one
solution to that problem, called <a href="https://github.com/westermo/querierd/">querierd</a>.</p>

<p>However, first we need to talk a bit about IGMP and MLD, which are
foreign concepts to many, and magical buggy fairy dust that doesn’t
work, to some.</p>

<blockquote>
  <p>Actually, it’s not at all uncommon that many IGMP/IGMP snooping
implementations in the wild are buggy.  So you can find many (!) live
networks out there that simply have disabled it on all switches just
to get anything to work.  This is of course both unsafe and can cause
a lot of overload on end devices, since unregulated multicast is then
treated as broadcast.</p>
</blockquote>

<h2>IGMP/MLD</h2>

<p>IGMP/MLD snooping means a switch, or in this case the Linux bridge, can
“snoop” on the IGMP traffic from the elected querier and all multicast
receivers on a LAN.  <a href="https://datatracker.ietf.org/doc/html/rfc3376">IGMP</a> is the control protocol for IPv4 multicast
and <a href="https://datatracker.ietf.org/doc/html/rfc3810">MLD</a> is the control protocol for IPv6 multicast.  Both regulate
the flow of multicast on a LAN and are <em>very</em> similar, except for the IP
protocol.  We will focus on IPv4 in this post.</p>

<p>The basic mechanism in IGMP is similar to a newspaper subscription, a
sales person (querier) calls up potential customers (all end devices) in
their distribution area (LAN); “Do you want multicast? (Query)” and the
customers (end devices) answer (IGMP report) with the newspaper(s)
(group(s) they want to subscribe to.</p>

<p>As you can see, there are two types of IGMP/MLD control packets:</p>

<ol>
  <li>IGMP/MLD query, sent by the elected querier</li>
  <li>IGMP/MLD report, also called “join” or “leave” from earlier
protocol versions.  E.g., an end device wants to “join a group”,
meaning; stop filtering this group for me</li>
</ol>

<p>The IGMP/MLD <em>snooping mechanism</em> is responsible for:</p>

<ol>
  <li>Forwarding queries from the elected querier to all end devices on
the same LAN (members of the same VLAN).</li>
  <li>Forwarding responses to queries (reports) from end devices to the
querier.</li>
</ol>

<p>In both cases it then uses the information of which port the querier is
connected to, and which port(s) an IGMP/MLD reply was received on.
These ports are then used to selectively: flood multicast data towards
the querier, and forward multicast data (or not) to end devices.</p>

<ol>
  <li>The port where queries are received, this is where all multicast
data should be flooded – it’s the distribution point for all
multicast, which may or may not be routed further.</li>
  <li>The port(s) which send multicast subscription replies (reports)
are recorded in “filters”, one filter per group (per VLAN) with a
list of ports to forward to.</li>
</ol>

<p>The bridge can be configured to, by default, flood or <em>not</em> flood
unknown multicast traffic to end devices.  In many setups you may want
to prohibit flooding by default, so that multicast is only forwarded if
an end device has subscribed to it.  However, due to limitations in the
underlying switching chipsets, this “block by default” approach may not
always be possible.  So, a compromise, which is also the Linux bridge’s
default, is to have flooding of unknown/unregistered multicast per port
enabled by default, and start filtering when it knows more.  I.e., when
it has snooped its first IGMP/MLD report.</p>

<h2>Setup</h2>

<p>The setup presented in this blog post is very limited.  There are no
VLAN trunk ports, only a basic bridge split in two separate broadcast
domains.  Please see the <a href="/2020/03/25/linux-networking-bridge/">Linux Networking Bridge</a> post if you want a
refresher of the basics.</p>

<p>The default setup in <a href="https://github.com/westermo/netbox/">NetBox</a> is to have all ports in VLAN 1, so add
the second VLAN, move the ports, and remember to set <code class="language-plaintext highlighter-rouge">br0</code> as tagged
member of both VLANs:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    IP: 192.168.1.1   vlan1     vlan2   IP: 192.168.2.1
                           \   /
                            br0
                       ______|______
                      |#_#_#_#_#_#_#|
                      /  |   :  |    \ 
                  eth0 eth1  :  eth2 eth3
                             :
                    VLAN 1   :    VLAN 2
</code></pre></div></div>

<p>With the basic setup out of the way, we enable multicast snooping and
IGMPv3 proxy querier on the bridge.  This is the load bearing feature
that we later build on with <code class="language-plaintext highlighter-rouge">querierd</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ bridge vlan global set vid 1 dev br0 mcast_snooping 1 mcast_querier 1 mcast_igmp_version 3
$ bridge vlan global set vid 2 dev br0 mcast_snooping 1 mcast_querier 1 mcast_igmp_version 3
</code></pre></div></div>

<blockquote>
  <p>Enabling IGMP/MLD snooping per VLAN, and other per VLAN settings, on
the bridge is only possible using iproute2 v5.16.0, or later.  In our
examples we use <a href="https://github.com/westermo/netbox/">NetBox</a>, which has all the necessary tools and a
matching kernel.  See that project for how to build the OS profile of
the <em>Zero</em> target (x86_64) to play with this in Qemu (<code class="language-plaintext highlighter-rouge">make run</code>).
Remember to set <code class="language-plaintext highlighter-rouge">QEMU_N_NICS=4</code>!</p>
</blockquote>

<p>As soon as the vlan1 and vlan2 interfaces are UP, the bridge initiates
IGMP queries on both VLANs, so you should see unique queries going out
on all eth-ports.  In both <a href="https://www.man7.org/linux/man-pages/man8/tcpdump.8.html">tcpdump(8)</a> and Wireshark you can see the
IGMPv3 flag being set:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>joachim@wbg:~$ tcpdump -plni qtap3 
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on qtap3, link-type EN10MB (Ethernet), capture size 262144 bytes
17:26:05.697222 IP6 fe80::5054:ff:fe12:3456 &gt; ff02::1: HBH ICMP6, multicast listener query v2 [gaddr ::], length 28
17:26:05.697345 IP 0.0.0.0 &gt; 224.0.0.1: igmp query v3
</code></pre></div></div>

<p>To see all the per-VLAN settings:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@zero:~# bridge vlan global show
port              vlan-id
br0               1-2
                    mcast_snooping 1 mcast_querier 1 mcast_igmp_version 3 mcast_mld_version 2 mcast_last_member_count 2 mcast_last_member_interval 100 mcast_startup_query_count 2 mcast_startup_query_interval 3125 mcast_membership_interval 26000 mcast_querier_interval 25500 mcast_query_interval 12500 mcast_query_response_interval 1000 
</code></pre></div></div>

<p>The query interval (125 sec) and router timeout (255 sec) are default
values from the RFCs.  Notice the scale of these, so if you want to
change them you don’t set them too low!  See the RFC for recommended
defaults, e.g. timeout = 2 * 125 + 10/2.</p>

<h2>querierd</h2>

<p>Now, to address the inherent problems of only having a proxy querier,
mentioned in the introduction.  Westermo developed a small and basic
querier daemon for userspace, called <a href="https://github.com/westermo/querierd/">querierd</a>.  It is derived from
the upstream <a href="https://github.com/troglobit/mrouted/">mrouted</a> project and then whacked at with a bat to get
into shape for its new task.</p>

<p>querierd is installed by default in NetBox, it starts up by default on
<code class="language-plaintext highlighter-rouge">vlan1</code>, so all we have to do is uncomment the second to last line to
activate it also on our <code class="language-plaintext highlighter-rouge">vlan2</code> interface:</p>

<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># /etc/querierd.conf: default NetBox configuration
</span>
<span class="c"># Query interval can be [1,1024], default 125.  Recommended not go below 10
#query-interval 125
</span>
<span class="c"># The interval inside the query-interval that clients should respond
#query-response-interval 10
</span>
<span class="c"># Last member query interval [1,1024], default 1.  The igmp-robustness
# setting controls the last member query count.
#query-last-member-interval 1
</span>
<span class="c"># Querier's robustness can be [2,10], default 2.  Recommended to use 2
#robustness 2
</span>
<span class="c"># Controls the "other querier present interval", used to detect when an
# elected querier stops sending queries.  Leave this commented-out, it
# is only available to override particular use-cases and interip with
# devices that do not follow the RFC.  When commented out, the timeout
# is calculated from the query interval and robustness according to RFC.
#router-timeout 255
</span>
<span class="c"># IP Option Router Alert is enabled by default, for interop with stacks
# that hard-code the length of the IP header
#no router-alert
</span>
<span class="c"># Enable and one of the IGMP versions to use at startup, with fallback
# to older versions if older clients appear.
</span><span class="n">iface</span> <span class="n">vlan1</span> <span class="n">enable</span> <span class="n">igmpv3</span>
<span class="n">iface</span> <span class="n">vlan2</span> <span class="n">enable</span> <span class="n">igmpv3</span>
<span class="c">#iface vlan3 enable igmpv3
</span></code></pre></div></div>

<p>If you want, you can uncomment also <code class="language-plaintext highlighter-rouge">vlan3</code>, even though it doesn’t
exist (yet), querierd does not go to the sad place, it’s just prepared
to automatically start as soon as it’s added, UP, and has an IP address.</p>

<p>Remember to restart the daemon after you change its .conf file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@zero:~# initctl restart querierd
</code></pre></div></div>

<p>To see the status, we use the <code class="language-plaintext highlighter-rouge">querierctl</code> tool:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@zero:~# querierctl -p
Multicast Overview
-------------------------------------------------------------------------------
Query Interval          : 125 sec
Robustness Value        : 2
Router Timeout          : 255
Fast Leave Ports        : 
Router Ports            : 
Flood Ports             : eth0, eth3, eth1, eth2

Interface         State     Querier               Timeout  Ver
-------------------------------------------------------------------------------
vlan1             Up        192.168.1.1           None       3
vlan2             Down      0.0.0.0               None       3

 VID  Multicast MAC         Multicast Group       Ports
-------------------------------------------------------------------------------
   1  01:00:5E:7F:FF:FA     239.255.255.250       br0, eth0
</code></pre></div></div>

<p>This reminds us that we haven’t yet set an IP address, or even brought
the interface UP!  So we do that, and assign the proper address (without
restarting querierd):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@zero:~# ip link set vlan2 up
root@zero:~# ip addr add 192.168.2.1/24 dev vlan2
root@zero:~# querierctl -p
Multicast Overview
-------------------------------------------------------------------------------
Query Interval          : 125 sec
Robustness Value        : 2
Router Timeout          : 255
Fast Leave Ports        : 
Router Ports            : 
Flood Ports             : eth0, eth3, eth1, eth2

Interface         State     Querier               Timeout  Ver
-------------------------------------------------------------------------------
vlan1             Up        192.168.1.1           None       3
vlan2             Up        192.168.2.1           None       3

 VID  Multicast MAC         Multicast Group       Ports
-------------------------------------------------------------------------------
   1  01:00:5E:7F:FF:FA     239.255.255.250       br0, eth0
</code></pre></div></div>

<h2>Exercise</h2>

<p>Now, as an exercise to the reader, you can start playing around with the
setup.  <a href="https://github.com/libnet/nemesis/">Emulate IGMP</a> reports from end devices, investigate
the various querierctl commands, and compatibility output options.
E.g., we use <code class="language-plaintext highlighter-rouge">-p</code> here only to make the output more blog friendly.</p>

<p>Also, connect multiple NetBox devices, using <a href="https://github.com/wkz/qeneth">qeneth</a> or GNS3, to test
querier election (lowest IP in a LAN wins, except for 0.0.0.0), and
router (querier) timeout with fail-over to another querierd.</p>

<h2>Future</h2>

<p>Much if the original innards of querierd have been gutted and new DNA
strands grafted onto it from other related projects, such as <a href="https://github.com/troglobit/pimd/">pimd</a>.
The only missing part, currently, is the MLD v1/v2 querier support,
which is planned to be grafted from <a href="https://github.com/troglobit/pim6sd/">pim6sd</a>.</p>

<p>There are however other possibilities, one such is to convert it to a
full-blown <code class="language-plaintext highlighter-rouge">bridged</code> (plans for this are currently shelved), which can
take care of all the layer-2 bridge setup (port VLAN memberships, and
all per-VLAN settings) and active functions like a querier for IGMP/MLD
but also GMRP/MMRP for MAC based multicast subscription, and other types
of layer-2 services and policy that don’t belong in the kernel.</p>

<h2>Footnotes</h2>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Well not really, there <em>is</em> support for using the IP address of
the bridge, but you do not want to use that since the kernel will go
dumpster diving for <em>any</em> address. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>A multicast router can be any of the DVMRP or PIM families of
protocols.  Open implementations of these include, but are not
limited to: <a href="https://github.com/troglobit/mrouted/">mrouted</a>, <a href="https://github.com/troglobit/pimd/">pimd</a>, <a href="https://github.com/troglobit/pimd-dense/">pimd-dense</a>, and PIM-SM/SSM in
<a href="https://quagga.net/">Quagga</a>, and <a href="https://frrouting.org/">Frr</a>. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Remember, unregulated multicast is broadcast.  Meaning you can
easily run into overloading your networks. <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; Westermo Engineers - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://westermo.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
