<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Tools of the Trade :: ping &amp; tcpdump</title>
  <meta name="description" content="Continuing the series with another set of really useful tools to know: ping(8) and tcpdump(8). They can be used to localize issues in just about any network setup. Ping is capable of generating unicast, multicast, and broadcast traffic. While tcpdump is capable of capturing, formatting, and most importantly filtering all types of traffic.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://westermo.github.io/2021/06/12/ping-and-tcpdump/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Westermo Labs" href="https://westermo.github.io/feed.xml">

  

  
  <meta property="og:title" content="Tools of the Trade :: ping &amp; tcpdump">
  <meta property="og:site_name" content="Westermo Labs">
  <meta property="og:url" content="https://westermo.github.io/2021/06/12/ping-and-tcpdump/">
  <meta property="og:description" content="Continuing the series with another set of really useful tools to know: ping(8) and tcpdump(8). They can be used to localize issues in just about any network setup. Ping is capable of generating unicast, multicast, and broadcast traffic. While tcpdump is capable of capturing, formatting, and most importantly filtering all types of traffic.">
  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Tools of the Trade :: ping &amp; tcpdump">
  <meta name="twitter:description" content="Continuing the series with another set of really useful tools to know: ping(8) and tcpdump(8). They can be used to localize issues in just about any network setup. Ping is capable of generating uni...">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Westermo Labs</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
        
        <a class="page-link" href="https://github.com/westermo/">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Tools of the Trade :: ping &amp; tcpdump</h1>
    
    <p class="post-meta"><time datetime="2021-06-12T07:16:23+02:00" itemprop="datePublished">Jun 12, 2021</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Joachim Wiberg</span></span>

 •
  
    
    
      
    
      
        <a href="/tags/howto/">howto</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
        <a href="/tags/tools/">tools</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Continuing the series with another set of really useful tools to know:
<a href="https://www.man7.org/linux/man-pages/man8/ping.8.html">ping(8)</a> and
<a href="https://www.man7.org/linux/man-pages/man8/tcpdump.8.html">tcpdump(8)</a>.
They can be used to localize issues in just about any network setup.</p>

<p>Ping is capable of generating unicast, multicast, and broadcast traffic.
While tcpdump is capable of capturing, formatting, <em>and most importantly
filtering</em> all types of traffic.</p>

<!-- more -->

<p>Recall the last picture from <a href="/2020/03/25/linux-networking-bridge/">Linux Networking Bridge</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  vlan1     vlan2              vlan1     vlan2
       \   /                        \   /
        br0  1T,2T                   br0  1T,2T,3T
     ____|____                    ____|__________
    [#_#_#_#_#]                  [#_#_#_#_#_#_#_#]
    /  |      \                  /  |   |   \    \
eth2  eth1     eth0----------eth0 eth1 eth2  eth3 eth4
 2U    1U             1T,2T        1U   2U    3U   3U
 |     |                           |    |     |    |
 |     |                           |    |     |    |
eth0  eth0                        eth0 eth0  eth0 eth0
ED1   ED2                         ED3  ED4   ED5  ED6
</code></pre></div></div>
<p><em>Figure 1: All end-devices (ED) have a single interface <code class="language-plaintext highlighter-rouge">eth0</code></em></p>

<p>Much can go wrong setting that up.  Not just with the standard Linux
bridge, but also with any HW offloading switch, and their respective
drivers.   To test the setup we can use our friends ping and tcpdump.
The following subnets and IP addresses are used:</p>

<p><strong>Subnets:</strong></p>

<ul>
  <li>VLAN 1: 192.168.1.0/24</li>
  <li>VLAN 2: 192.168.2.0/24</li>
</ul>

<p><strong>Left:</strong></p>

<ul>
  <li>vlan1: 192.168.1.1</li>
  <li>vlan2: 192.168.2.1</li>
  <li>ED1: 192.168.2.11</li>
  <li>ED2: 192.168.1.11</li>
</ul>

<p><strong>Right:</strong></p>

<ul>
  <li>vlan1: 192.168.1.2</li>
  <li>vlan2: 192.168.2.2</li>
  <li>ED3: 192.168.1.22</li>
  <li>ED4: 192.168.2.22</li>
  <li>ED5: 192.168.3.33</li>
  <li>ED6: 192.168.3.34</li>
</ul>

<h2>Connectivity Between 2.11 and 2.22</h2>

<p>We start by verifying connectivity between ED1 on the left and ED4 on
the right.  They should both be untagged members in VLAN 2, and the VLAN
trunk between the bridges should carry the same VLAN tagged.  From ED1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@ed1:~# ping 192.168.2.22
</code></pre></div></div>

<p>If we don’t get a reply we can check with tcpdump on ED4:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@ed4:~# tcpdump -lni eth0 icnmp
</code></pre></div></div>

<p>Dead silence.  So we go back to ED1 and change to a broadcast ping, this
should reach everyone connected to VLAN 2.  We check this with tcpdump
on all other ports.  First we check to see if we see anything on the
left bridge’s VLAN 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@ed1:~# ping -b 192.168.2.255
root@left:~# tcpdump -lni vlan2 icmp
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on vlan2, link-type EN10MB (Ethernet), snapshot length 262144 bytes
08:49:32.306657 IP 192.168.2.11 &gt; 192.168.2.255: ICMP echo request, id 5, seq 54, length 64
08:49:33.330651 IP 192.168.2.11 &gt; 192.168.2.255: ICMP echo request, id 5, seq 55, length 64
08:49:34.354554 IP 192.168.2.11 &gt; 192.168.2.255: ICMP echo request, id 5, seq 56, length 64
08:49:35.378632 IP 192.168.2.11 &gt; 192.168.2.255: ICMP echo request, id 5, seq 57, length 64
</code></pre></div></div>

<p>Here we see the ICMP traffic, so we can move on to check if we get the
same traffic on the right-hand bridge as well:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@right:~# tcpdump -lni vlan2 icmp
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on vlan2, link-type EN10MB (Ethernet), snapshot length 262144 bytes
08:51:58.738186 IP 192.168.2.11 &gt; 192.168.2.255: ICMP echo request, id 5, seq 197, length 64
08:51:59.762284 IP 192.168.2.11 &gt; 192.168.2.255: ICMP echo request, id 5, seq 198, length 64
08:52:00.786212 IP 192.168.2.11 &gt; 192.168.2.255: ICMP echo request, id 5, seq 199, length 64
</code></pre></div></div>

<p>Yup, so what’s wrong here?  Verify the VLAN membership on the bridge:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@right:~# bridge vlan
port              vlan-id
eth4              3 PVID Egress Untagged
eth3              3 PVID Egress Untagged
eth2              1 PVID Egress Untagged
eth1              2 PVID Egress Untagged
eth0              1
                  2
br0               1
                  2
</code></pre></div></div>

<p>There we have it!  Ports <code class="language-plaintext highlighter-rouge">eth1</code> and <code class="language-plaintext highlighter-rouge">eth2</code> had been mixed up in their
VLAN assignments!</p>

<h2>Deep Dive in the Stack</h2>

<p>Now that we’ve covered a basic troubleshooting case, let’s dive into the
various layers in the networking stack of one of the bridging devices.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    IP: 192.168.1.1   vlan1     vlan2   IP: 192.168.2.1
                           \   /
                            br0
                       ______|______
                      |#_#_#_#_#_#_#|
                      /  |   :  |    \ 
                  eth1 eth2  :  eth3 eth4
                             :
                    VLAN 1   :    VLAN 2
</code></pre></div></div>

<p>We use the same basic tools, inject ICMP traffic with ping on one port
and use tcpdump to see where it ends up.  Here we’ll use broadcast from
an “end-device” attached to eth0:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    IP: 192.168.1.1   vlan1     vlan2   IP: 192.168.2.1
                           \   /
                            br0
NS1: 192.168.1.10      ______|______
--------.             |#_#_#_#_#_#_#|
lo      :             /  |   :  |    \ 
eth0    :         eth1 eth2  :  eth3 eth4
    `-------------'          :
--------'           VLAN 1   :    VLAN 2
</code></pre></div></div>

<p>The “end-device” is a network namespace on a dedicated device, with a
dedicated network card, or a VETH pair with one end in the namespace,
and the other attached to the bridge.  The latter is useful for testing
on the same device where the bridge runs.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@ns1:~# ping -b 192.168.1.255
</code></pre></div></div>

<p>On the system itself we can start by running tcpdump at the bottom, the
interface connected to the bridge.  This should work regardless if the
system has bridging (switch) offloading to an underlying hardware, since
broadcast is forwarded to all hosts on a LAN.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@system:~# tcpdump -lni eth1 icmp
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on eth3, link-type EN10MB (Ethernet), snapshot length 262144 bytes
09:05:26.671368 IP 192.168.1.10 &gt; 192.168.1.255: ICMP echo request, id 5, seq 986, length 64
09:05:27.695401 IP 192.168.1.10 &gt; 192.168.1.255: ICMP echo request, id 5, seq 987, length 64
09:05:28.719354 IP 192.168.1.10 &gt; 192.168.1.255: ICMP echo request, id 5, seq 988, length 64
</code></pre></div></div>

<p>Here we can see basic ICMP frames, nothing strange, but we know there’s
more going on here, so we add <code class="language-plaintext highlighter-rouge">-e</code> to get the Ethernet header as well:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@system:~# tcpdump -elni eth1 icmp
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on eth1, link-type EN10MB (Ethernet), snapshot length 262144 bytes
09:07:01.903045 3c:18:a0:07:32:46 &gt; ff:ff:ff:ff:ff:ff, ethertype IPv4 (0x0800), length 98: 192.168.1.10 &gt; 192.168.1.255: ICMP echo request, id 5, seq 1079, length 64
09:07:02.927090 3c:18:a0:07:32:46 &gt; ff:ff:ff:ff:ff:ff, ethertype IPv4 (0x0800), length 98: 192.168.1.10 &gt; 192.168.1.255: ICMP echo request, id 5, seq 1080, length 64
09:07:03.951079 3c:18:a0:07:32:46 &gt; ff:ff:ff:ff:ff:ff, ethertype IPv4 (0x0800), length 98: 192.168.1.10 &gt; 192.168.1.255: ICMP echo request, id 5, seq 1081, length 64
</code></pre></div></div>

<p>Nothing much interesting still, just a standard Ethernet header.
Destination address ff:ff:ff:ff:ff:ff is the broadcast address,
and 3c:18:a0:07:32:46 is the source MAC address of eth0 in the
NS1 namespace.  The type/len field is 0x0800, which tcpdump has
translated to IPv4 for us.</p>

<p>OK, so port <code class="language-plaintext highlighter-rouge">eth1</code> is attached to the bridge, let’s check the
bridge interface to see if there’s anything interesting going
on there, again with the <code class="language-plaintext highlighter-rouge">-e</code> option:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@system:~# tcpdump -elni br0 icmp
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on br0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
09:08:25.870765 3c:18:a0:07:32:46 &gt; ff:ff:ff:ff:ff:ff, ethertype 802.1Q (0x8100), length 102: vlan 1, p 0, ethertype IPv4 (0x0800), 192.168.2.42 &gt; 192.168.2.255: ICMP echo request, id 5, seq 1161, length 64
09:08:26.894762 3c:18:a0:07:32:46 &gt; ff:ff:ff:ff:ff:ff, ethertype 802.1Q (0x8100), length 102: vlan 1, p 0, ethertype IPv4 (0x0800), 192.168.2.42 &gt; 192.168.2.255: ICMP echo request, id 5, seq 1162, length 64
09:08:27.918788 3c:18:a0:07:32:46 &gt; ff:ff:ff:ff:ff:ff, ethertype 802.1Q (0x8100), length 102: vlan 1, p 0, ethertype IPv4 (0x0800), 192.168.2.42 &gt; 192.168.2.255: ICMP echo request, id 5, seq 1163, length 64
</code></pre></div></div>

<p>Finally, something interesting!  On ingress the bridge has marked all
ICMP frames from NS1 as member of VLAN 1.  This is called a VLAN “tag”
and all Ethernet frames inside the bridge has one (in a bridge with
<code class="language-plaintext highlighter-rouge">vlan_filtering</code> enabled).  It is used to determine which ports in
a bridge that are eligible to receive the frame, only our tagged and
untagged ports in VLAN 1 in this case.  Since this is broadcast, all
ingressing frames will egress all other ports in VLAN 1.</p>

<p>If we change to ping the unicast address of the <code class="language-plaintext highlighter-rouge">vlan1</code> interface on
<code class="language-plaintext highlighter-rouge">br0</code>, a few other interesting things emerge:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@ns1:~# ping 192.168.1.1
PING 192.168.1.10 (192.168.2.122) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=1.08 ms
</code></pre></div></div>

<p>First of all, we get a reply!  By default, Linux does not reply to
broadcast pings (configurable, but outside the scope of this blog, see
<a href="https://www.man7.org/linux/man-pages/man8/sysctl.8.html">sysctl(8)</a>).
The output from tcpdump on our system tells a similar story, only the
destination MAC address is now first the MAC address of the <code class="language-plaintext highlighter-rouge">vlan1</code>
interface, and then in the reply, the MAC address of our <code class="language-plaintext highlighter-rouge">eth0</code> in
NS1.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@system:~# tcpdump -elni br0 icmp
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on br0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
09:20:26.272791 3c:18:a0:07:32:46 &gt; 0e:de:c5:a9:cb:01, ethertype 802.1Q (0x8100), length 102: vlan 1, p 0, ethertype IPv4 (0x0800), 192.168.2.42 &gt; 192.168.2.122: ICMP echo request, id 6, seq 6, length 64
09:20:26.273073 0e:de:c5:a9:cb:01 &gt; 3c:18:a0:07:32:46, ethertype 802.1Q (0x8100), length 102: vlan 1, p 0, ethertype IPv4 (0x0800), 192.168.2.122 &gt; 192.168.2.42: ICMP echo reply, id 6, seq 6, length 64
</code></pre></div></div>

<p>The bridge has <code class="language-plaintext highlighter-rouge">learning</code> enabled and figures out the port to forward
the reply on using its forwarding database (FDB), let’s inspect it!</p>

<blockquote>
  <p>The FDB is for unicast and the MDB is for multicast addresses.  On
some physical switchcore fabrics this is a single entity, sometimes
referred to as Address Translation Unit (ATU)</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@system:~# bridge fdb show
...
3c:18:a0:07:32:46 dev eth1 vlan 1 master br0
...
</code></pre></div></div>

<p>There’s a lot of output, but the interesting line is the one matching
the MAC address we’re looking for.  This line tells us the end station
is downstream on port <code class="language-plaintext highlighter-rouge">eth1</code>, and we learned this on VLAN 1 and on
bridge <code class="language-plaintext highlighter-rouge">br0</code>.  So we check with tcpdump that we only see the reply
on port <code class="language-plaintext highlighter-rouge">eth1</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@basis:~# tcpdump -elni eth1 icmp
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on eth1, link-type EN10MB (Ethernet), snapshot length 262144 bytes
09:32:27.118368 3c:18:a0:07:32:46 &gt; 0e:de:c5:a9:cb:01, ethertype IPv4 (0x0800), length 98: 192.168.2.42 &gt; 192.168.2.122: ICMP echo request, id 7, seq 1, length 64
09:32:27.118739 0e:de:c5:a9:cb:01 &gt; 3c:18:a0:07:32:46, ethertype IPv4 (0x0800), length 98: 192.168.2.122 &gt; 192.168.2.42: ICMP echo reply, id 7, seq 1, length 64
</code></pre></div></div>

<p>Yup, only on <code class="language-plaintext highlighter-rouge">eth1</code> and we also see that the bridge has stripped the
VLAN tag from the frame on egreess to the wire.  Remember, port <code class="language-plaintext highlighter-rouge">eth1</code>
is an <em>untagged</em> member of VLAN 1 on <code class="language-plaintext highlighter-rouge">br0</code>.</p>


  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; Westermo Engineers - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://westermo.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
